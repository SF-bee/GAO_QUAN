萌新写的第一篇题解(●ˇ∀ˇ●)

## 题目大意

在平面内有若干个挡板，可以从上方的挡板的边缘竖直到达下方的挡板。每移动 1 单位或竖直下降 1单位会耗费 1 单位的时间。求从第 $s$ 个挡板到达第 $t$ 个挡板所需的最短时间。

## 思路

首先对于任意一块挡板，我们只有从左边掉落或右边掉落两种情况，并且只能掉落在挡板上。

每个节点有左和右两个节点，我们就很容易想到二叉树。我们可以把这个问题抽象成在二叉树上求两个节点的最短路

我们可以先处理出每块挡板的左右两端会掉落到哪一块挡板

```cpp
struct board{
    int l,r,h;  //l 代表挡板左端点，r 代表挡板右端点，h 代表挡板高度
};
std::array<board,MAX> a;
std::pair<int,int> down[MAX];

for(int i = 1;i <= n;i++){
    for(int j = 1;j <= n;j++){
        if(a[j].h < a[i].h){
            down[i].first = (a[j].l <= a[i].l && a[i].l <= a[j].r && a[j].h > a[down[i].first].h ? 
                        j : down[i].first);  //左边落点
            down[i].second = (a[j].l <= a[i].r && a[i].r <= a[j].r && a[j].h > a[down[i].second].h ? 
                        j : down[i].second);  //右边落点
        }
        
    }
}
```

这样我们就可以求出了从每块挡板的左右两边掉落的节点编号，那么边权怎么办呢？边权应该是落到当前挡板后走到左右两端所需要的距离。我们不需要计算高度，因为无法爬回上方挡板，因此高度总是 $h_s$ 和 $h_t$ 的差。

显然，我们并不能计算当前挡板到左右两端的距离是什么，因为我们无法得知我们会从上方落到挡板的什么位置。既然无法求出当前挡板，那么我们就求下方挡板的边权，这样我们就可以知道会落在挡板的什么位置了。

```cpp
std::vector<node> g[MAX];  //g是邻接表，存储左右两边的顶点和边权

// 建图，边权为落点到左右两边的距离
for(int i = 1;i <= n;i++){
    //左边挡板的边权
    if(down[i].first != 0){
        g[down[i].first].push_back({down[down[i].first].first,a[i].l - a[down[i].first].l});
        g[down[i].first].push_back({down[down[i].first].second,a[down[i].first].r -  a[i].l});
    }
    //右边挡板的边权
    if(down[i].second != 0){
        g[down[i].second].push_back({down[down[i].second].first,a[i].r - a[down[i].second].l});
        g[down[i].second].push_back({down[down[i].second].second,a[down[i].second].r -  a[i].r});
    }
}
```

图已经建好了，我们只需要再处理一下起点就可以开始跑 Dijkstra 了。

```cpp
//Dijkstra
g[s].clear();
g[s].push_back({down[s].first,0});
g[s].push_back({down[s].second,a[s].r - a[s].l});
dis.fill(INT_MAX);
dis[s] = 0;
std::priority_queue<node> que;
que.push({s,0});
while(!que.empty()){
    auto [u,d] = que.top();que.pop();
    if(vis[u]) continue;
    vis[u] = true;
    for(auto v : g[u]){
        auto [to,d] = v;
        if(to != 0 && dis[to] > dis[u] + d){
            dis[to] = dis[u] + d;
            que.push({to,dis[to]});
        }
    }
}
std::cout << (dis[t] != INT_MAX ? dis[t] + a[s].h - a[t].h : -1);#include <bits/stdc++.h>
const int MAX = 1e3 + 5;

struct board{
    int l,r,h;
};
struct node{
    int to,dis;
    bool operator< (const node &rhs) const{
        return dis > rhs.dis;
    }
};

inline board rd(){board x; std::cin >> x.l >> x.r >> x.h; return x;}

int n,s,t;
std::array<board,MAX> a;
std::array<int,MAX> dis;
std::array<bool,MAX> vis;  //记录节点是否抵达过
std::vector<node> g[MAX];  //g是邻接表，存储左右两边的顶点和边权
std::pair<int,int> down[MAX];  //0存左边的落点，1存右边落点

int main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    std::cin >> n >> s >> t;
    std::generate_n(a.begin() + 1,n,rd);
    
    //存储每块板子往左右两边会掉到哪块板子
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= n;j++){
            if(a[j].h < a[i].h){
                down[i].first = (a[j].l <= a[i].l && a[i].l <= a[j].r && a[j].h > a[down[i].first].h ? 
                            j : down[i].first);  //左边落点
                down[i].second = (a[j].l <= a[i].r && a[i].r <= a[j].r && a[j].h > a[down[i].second].h ? 
                            j : down[i].second);  //右边落点
            }
            
        }
    }
    // 建图，边权为落点到左右两边的距离
    for(int i = 1;i <= n;i++){
        //左边挡板的边权
        if(down[i].first != 0){
            g[down[i].first].push_back({down[down[i].first].first,a[i].l - a[down[i].first].l});
            g[down[i].first].push_back({down[down[i].first].second,a[down[i].first].r -  a[i].l});
        }
        //右边挡板的边权
        if(down[i].second != 0){
            g[down[i].second].push_back({down[down[i].second].first,a[i].r - a[down[i].second].l});
            g[down[i].second].push_back({down[down[i].second].second,a[down[i].second].r -  a[i].r});
        }
    }
    //Dijkstra
    g[s].clear();
    g[s].push_back({down[s].first,0});
    g[s].push_back({down[s].second,a[s].r - a[s].l});
    dis.fill(INT_MAX);
    dis[s] = 0;
    std::priority_queue<node> que;
    que.push({s,0});
    while(!que.empty()){
        auto [u,d] = que.top();que.pop();
        if(vis[u]) continue;
        vis[u] = true;
        for(auto v : g[u]){
            auto [to,d] = v;
            if(to != 0 && dis[to] > dis[u] + d){
                dis[to] = dis[u] + d;
                que.push({to,dis[to]});
            }
        }
    }
    std::cout << (dis[t] != INT_MAX ? dis[t] + a[s].h - a[t].h : -1);
    return 0;//完结撒花
}
```

### AC Code

```cpp
#include <bits/stdc++.h>
const int MAX = 1e3 + 5;

struct board{
    int l,r,h;
};
struct node{
    int to,dis;
    bool operator< (const node &rhs) const{
        return dis > rhs.dis;
    }
};

inline board rd(){board x; std::cin >> x.l >> x.r >> x.h; return x;}

int n,s,t;
std::array<board,MAX> a;
std::array<int,MAX> dis;
std::array<bool,MAX> vis;  //记录节点是否抵达过
std::vector<node> g[MAX];  //g是邻接表，存储左右两边的顶点和边权
std::pair<int,int> down[MAX];  //0存左边的落点，1存右边落点

int main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    std::cin >> n >> s >> t;
    std::generate_n(a.begin() + 1,n,rd);
    
    //存储每块板子往左右两边会掉到哪块板子
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= n;j++){
            if(a[j].h < a[i].h){
                down[i].first = (a[j].l <= a[i].l && a[i].l <= a[j].r && a[j].h > a[down[i].first].h ? 
                            j : down[i].first);  //左边落点
                down[i].second = (a[j].l <= a[i].r && a[i].r <= a[j].r && a[j].h > a[down[i].second].h ? 
                            j : down[i].second);  //右边落点
            }
            
        }
    }
    // 建图，边权为落点到左右两边的距离
    for(int i = 1;i <= n;i++){
        //左边挡板的边权
        if(down[i].first != 0){
            g[down[i].first].push_back({down[down[i].first].first,a[i].l - a[down[i].first].l});
            g[down[i].first].push_back({down[down[i].first].second,a[down[i].first].r -  a[i].l});
        }
        //右边挡板的边权
        if(down[i].second != 0){
            g[down[i].second].push_back({down[down[i].second].first,a[i].r - a[down[i].second].l});
            g[down[i].second].push_back({down[down[i].second].second,a[down[i].second].r -  a[i].r});
        }
    }
    //Dijkstra
    g[s].clear();
    g[s].push_back({down[s].first,0});
    g[s].push_back({down[s].second,a[s].r - a[s].l});
    dis.fill(INT_MAX);
    dis[s] = 0;
    std::priority_queue<node> que;
    que.push({s,0});
    while(!que.empty()){
        auto [u,d] = que.top();que.pop();
        if(vis[u]) continue;
        vis[u] = true;
        for(auto v : g[u]){
            auto [to,d] = v;
            if(to != 0 && dis[to] > dis[u] + d){
                dis[to] = dis[u] + d;
                que.push({to,dis[to]});
            }
        }
    }
    std::cout << (dis[t] != INT_MAX ? dis[t] + a[s].h - a[t].h : -1);//完结撒花
    return 0;
}
```